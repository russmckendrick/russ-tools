// Utility functions for generating Terraform code for AWS and Azure network resources
// To be implemented: generateAwsTerraform, generateAzureTerraform

export function generateAwsTerraform({ vpcName, vpcCidr, region, subnets }) {
  // Helper to sanitize Terraform resource names
  const safeName = (name) => name.replace(/[^a-zA-Z0-9_]/g, '_').toLowerCase();
  const vpcResourceName = safeName(vpcName || 'main_vpc');

  // Provider block
  let tf = `# AWS Terraform HCL export generated by russ.tools\n\nprovider \"aws\" {\n  region = \"${region || 'us-east-1'}\"\n}\n\n`;

  // VPC block
  tf += `resource \"aws_vpc\" \"${vpcResourceName}\" {\n  cidr_block = \"${vpcCidr}\"\n  enable_dns_support   = true\n  enable_dns_hostnames = true\n  tags = {\n    Name = \"${vpcName}\"\n  }\n}\n\n`;

  // Subnets
  subnets.forEach((subnet, idx) => {
    const subnetName = safeName(subnet.name || `subnet_${idx+1}`);
    tf += `resource \"aws_subnet\" \"${subnetName}\" {\n` +
      `  vpc_id            = aws_vpc.${vpcResourceName}.id\n` +
      `  cidr_block        = \"${subnet.cidr}\"\n` +
      (subnet.az ? `  availability_zone = \"${subnet.az}\"\n` : '') +
      `  map_public_ip_on_launch = ${subnet.public ? 'true' : 'false'}\n` +
      `  tags = {\n    Name = \"${subnet.name || `Subnet ${idx+1}`}\"\n  }\n` +
      `}\n\n`;
  });

  return tf.trim();
}


export function generateAzureTerraform({ vnetName, vnetCidr, location, subnets }) {
  // CAF-compliant: hyphens for Azure resource names, underscores for Terraform variables
  // CAF-compliant naming: [prefix]-[project]-[env]-[region]-[instance]
  function getRegionShort(loc) {
    // Example: uksouth -> uks, eastus2 -> eus2
    if (!loc) return 'xx';
    const match = loc.match(/^([a-z]+)[a-z]*([0-9]*)$/);
    if (!match) return loc.slice(0,3);
    const prefix = match[1].slice(0,3);
    const suffix = match[2] || '';
    return `${prefix}${suffix}`;
  }
  function cafResourceName(prefix, project, env, region, instance = '') {
    let name = [prefix, project, env, region, instance].filter(Boolean).join('-');
    name = name.toLowerCase().replace(/[^a-z0-9-]/g, '-').replace(/-+/g, '-').replace(/^-+|-+$/g, '');
    return name.slice(0, 80);
  }
  function tfVarName(name) {
    return String(name).toLowerCase().replace(/[^a-z0-9]/g, '_').replace(/_+/g, '_').replace(/^_+|_+$/g, '');
  }
  const rgVar = tfVarName('resource_group_name');
  const locVar = tfVarName('location');
  const env = 'prod';
  const regionShort = getRegionShort(location);
  const project = tfVarName(vnetName || 'main');

  // CAF names
  const rgName = cafResourceName('rg', project, env, regionShort);
  const vnetResName = cafResourceName('vnet', project, env, regionShort);
  const vnetTfName = tfVarName(vnetResName);
  const vnetResource = `resource "azurerm_virtual_network" "${vnetTfName}" {
  name                = "${vnetResName}"
  address_space       = ["${vnetCidr}"]
  location            = var.${locVar}
  resource_group_name = azurerm_resource_group.main.name
}`;
  const subnetResources = (subnets || []).map((subnet, idx) => {
    // Use subnet name as purpose, idx+1 as instance
    const purpose = tfVarName(subnet.name || `subnet${idx+1}`);
    const subnetResName = cafResourceName('snet', project, env, regionShort, (purpose !== project ? purpose : '') + (subnets.length > 1 ? `-${idx+1}` : ''));
    const subnetTfName = tfVarName(subnetResName);
    let cidr = '';
    if (subnet.base && subnet.cidr) {
      cidr = `${subnet.base}/${subnet.cidr}`;
    } else if (subnet.ip && subnet.cidr) {
      cidr = `${subnet.ip}/${subnet.cidr}`;
    } else if (subnet.cidrBlock) {
      cidr = subnet.cidrBlock;
    } else if (subnet.address_prefix) {
      cidr = subnet.address_prefix;
    }
    return `resource "azurerm_subnet" "${subnetTfName}" {
  name                 = "${subnetResName}"
  resource_group_name  = azurerm_resource_group.main.name
  virtual_network_name = azurerm_virtual_network.${vnetTfName}.name
  address_prefixes     = ["${cidr}"]
}`;
  }).join("\n\n");
  const rgResource = `resource "azurerm_resource_group" "main" {
  name     = "${rgName}"
  location = var.${locVar}
}`;
  const variables = `variable "${locVar}" {
  description = "Azure region"
  type        = string
  default     = "${location || 'uksouth'}"
}`;
  return [
    '# Azure Terraform HCL export generated by russ.tools',
    '',
    variables,
    '',
    rgResource,
    '',
    vnetResource,
    '',
    subnetResources
  ].join('\n');
}

export function generateVcdTerraform({ networkName, networkCidr, org, vdc, edgeGateway, subnets, networkType = 'routed' }) {
  // Helper to sanitize names for VCD (supports hyphens and underscores)
  const safeName = (name) => name.replace(/[^a-zA-Z0-9_-]/g, '-').toLowerCase();
  const networkResourceName = safeName(networkName || 'main-network');
  
  // Extract network details from CIDR
  const [networkIp, cidrPrefix] = networkCidr.split('/');
  const cidrNum = parseInt(cidrPrefix, 10);
  
  // Calculate netmask from CIDR
  const getNetmaskFromCidr = (cidr) => {
    const mask = (0xFFFFFFFF << (32 - cidr)) >>> 0;
    return [
      (mask >>> 24) & 0xFF,
      (mask >>> 16) & 0xFF,
      (mask >>> 8) & 0xFF,
      mask & 0xFF
    ].join('.');
  };
  
  const netmask = getNetmaskFromCidr(cidrNum);
  
  // Calculate gateway (typically first usable IP)
  const ipParts = networkIp.split('.').map(Number);
  const gatewayIp = [...ipParts];
  gatewayIp[3] = gatewayIp[3] + 1; // First usable IP after network address
  const gateway = gatewayIp.join('.');

  let tf = `# VMware Cloud Director Terraform HCL export generated by russ.tools\n\n`;
  
  // Provider configuration
  tf += `terraform {\n  required_providers {\n    vcd = {\n      source = "vmware/vcd"\n      version = "~> 3.10"\n    }\n  }\n}\n\n`;
  
  tf += `# Configure the VMware Cloud Director Provider\n`;
  tf += `provider "vcd" {\n  # Configuration will be provided via environment variables:\n`;
  tf += `  # VCD_USER, VCD_PASSWORD, VCD_ORG, VCD_URL, VCD_VDC\n  # Or via terraform.tfvars file\n}\n\n`;

  // Variables
  tf += `variable "org" {\n  description = "Organization name"\n  type        = string\n  default     = "${org || 'my-org'}"\n}\n\n`;
  tf += `variable "vdc" {\n  description = "VDC name"\n  type        = string\n  default     = "${vdc || 'my-vdc'}"\n}\n\n`;
  
  if (networkType === 'routed') {
    tf += `variable "edge_gateway" {\n  description = "Edge Gateway name"\n  type        = string\n  default     = "${edgeGateway || 'edge-gateway'}"\n}\n\n`;
  }

  // Main network resource
  if (networkType === 'routed') {
    tf += `resource "vcd_network_routed" "${networkResourceName}" {\n`;
    tf += `  org = var.org\n  vdc = var.vdc\n\n`;
    tf += `  name         = "${networkName || 'Main Network'}"\n`;
    tf += `  edge_gateway = var.edge_gateway\n`;
    tf += `  gateway      = "${gateway}"\n`;
    tf += `  netmask      = "${netmask}"\n\n`;
    tf += `  description = "Main network for ${networkName || 'infrastructure'}"\n\n`;
  } else {
    tf += `resource "vcd_network_isolated" "${networkResourceName}" {\n`;
    tf += `  org = var.org\n  vdc = var.vdc\n\n`;
    tf += `  name    = "${networkName || 'Main Network'}"\n`;
    tf += `  gateway = "${gateway}"\n`;
    tf += `  netmask = "${netmask}"\n\n`;
    tf += `  description = "Isolated network for ${networkName || 'infrastructure'}"\n\n`;
  }

  // Add static IP pools for subnets
  if (subnets && subnets.length > 0) {
    subnets.forEach((subnet, idx) => {
      const subnetBlock = subnet.base && subnet.cidr ? 
        `${subnet.base}/${subnet.cidr}` : 
        `${subnet.ip || '192.168.1.0'}/${subnet.cidr || 24}`;
      
      const [subnetIp, subnetCidr] = subnetBlock.split('/');
      const subnetParts = subnetIp.split('.').map(Number);
      
      // Calculate usable range (skip network and broadcast addresses)
      const subnetSize = Math.pow(2, 32 - parseInt(subnetCidr, 10));
      const startOffset = 2; // Skip network address and gateway
      const endOffset = 2;   // Skip broadcast address and reserve one
      
      const startIp = [...subnetParts];
      startIp[3] = startIp[3] + startOffset;
      
      const endIp = [...subnetParts];
      endIp[3] = endIp[3] + subnetSize - endOffset - 1;
      
      tf += `  static_ip_pool {\n`;
      tf += `    start_address = "${startIp.join('.')}"\n`;
      tf += `    end_address   = "${endIp.join('.')}"\n`;
      tf += `  }\n`;
      
      if (idx < subnets.length - 1) tf += `\n`;
    });
  } else {
    // Default IP pool if no subnets specified
    const defaultStart = [...ipParts];
    defaultStart[3] = defaultStart[3] + 10;
    const defaultEnd = [...ipParts];
    defaultEnd[3] = defaultEnd[3] + 100;
    
    tf += `  static_ip_pool {\n`;
    tf += `    start_address = "${defaultStart.join('.')}"\n`;
    tf += `    end_address   = "${defaultEnd.join('.')}"\n`;
    tf += `  }\n`;
  }

  tf += `}\n\n`;

  // If we have multiple subnets, create separate isolated networks for true subnet isolation
  if (subnets && subnets.length > 1) {
    tf += `# Additional isolated networks for subnet isolation\n`;
    subnets.forEach((subnet, idx) => {
      const subnetName = safeName(subnet.name || `subnet-${idx + 1}`);
      const subnetBlock = subnet.base && subnet.cidr ? 
        `${subnet.base}/${subnet.cidr}` : 
        `${subnet.ip || '192.168.1.0'}/${subnet.cidr || 24}`;
      
      const [subnetIp, subnetCidr] = subnetBlock.split('/');
      const subnetParts = subnetIp.split('.').map(Number);
      const subnetNetmask = getNetmaskFromCidr(parseInt(subnetCidr, 10));
      
      // Gateway for this subnet (first usable IP)
      const subnetGateway = [...subnetParts];
      subnetGateway[3] = subnetGateway[3] + 1;
      
      tf += `\nresource "vcd_network_isolated" "${subnetName}" {\n`;
      tf += `  org = var.org\n  vdc = var.vdc\n\n`;
      tf += `  name    = "${subnet.name || `Subnet ${idx + 1}`}"\n`;
      tf += `  gateway = "${subnetGateway.join('.')}"\n`;
      tf += `  netmask = "${subnetNetmask}"\n\n`;
      tf += `  description = "Isolated subnet: ${subnet.name || `Subnet ${idx + 1}`}"\n\n`;
      
      // Calculate IP pool for this subnet
      const subnetSize = Math.pow(2, 32 - parseInt(subnetCidr, 10));
      const startIp = [...subnetParts];
      startIp[3] = startIp[3] + 2; // Skip network and gateway
      
      const endIp = [...subnetParts];
      endIp[3] = endIp[3] + subnetSize - 3; // Skip broadcast and reserve one
      
      tf += `  static_ip_pool {\n`;
      tf += `    start_address = "${startIp.join('.')}"\n`;
      tf += `    end_address   = "${endIp.join('.')}"\n`;
      tf += `  }\n`;
      tf += `}\n`;
    });
  }

  // Output values
  tf += `\n# Outputs\n`;
  tf += `output "network_id" {\n  description = "ID of the main network"\n  value       = vcd_network_${networkType}.${networkResourceName}.id\n}\n\n`;
  tf += `output "network_name" {\n  description = "Name of the main network"\n  value       = vcd_network_${networkType}.${networkResourceName}.name\n}\n`;

  if (subnets && subnets.length > 1) {
    tf += `\noutput "subnet_networks" {\n  description = "Map of subnet networks"\n  value = {\n`;
    subnets.forEach((subnet, idx) => {
      const subnetName = safeName(subnet.name || `subnet-${idx + 1}`);
      tf += `    "${subnet.name || `subnet-${idx + 1}`}" = vcd_network_isolated.${subnetName}.id\n`;
    });
    tf += `  }\n}\n`;
  }

  return tf.trim();
}
